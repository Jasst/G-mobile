<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bitcoin Key Finder</title>
<script src="bitcoinjs-lib.min.js"></script>
<style>
  :root {
    --bg: #121212;
    --card: #1e1e1e;
    --primary: #bb86fc;
    --text: #e0e0e0;
    --success: #4caf50;
    --input: #2d2d2d;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, sans-serif; }
  body { background: var(--bg); color: var(--text); line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; }
  header { text-align: center; margin-bottom: 20px; padding: 10px; border-bottom: 1px solid #333; }
  h1 { color: var(--primary); font-size: 1.8rem; }
  .card { background: var(--card); border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
  .form-group { margin-bottom: 15px; }
  label { display: block; margin-bottom: 5px; font-weight: 500; }
  input, select, button {
    width: 100%; padding: 12px; border-radius: 4px;
    border: 1px solid #333; background: var(--input);
    color: var(--text); font-size: 16px;
  }
  button {
    background: var(--primary); color: #000; font-weight: 600;
    cursor: pointer; border: none; transition: opacity 0.3s;
  }
  button:disabled { opacity: 0.6; cursor: not-allowed; }
  button:hover:not(:disabled) { opacity: 0.9; }
  .btn-group { display: flex; gap: 10px; }
  .btn-group button { flex: 1; }
  #toggleBtn.pause { background: #ff9800; }
  .log-container {
    max-height: 300px; overflow-y: auto; background: #000;
    border-radius: 4px; padding: 15px; font-family: monospace;
    white-space: pre-wrap; margin-top: 10px;
  }
  .found { color: var(--success); font-weight: bold; }
  .status {
    display: flex; justify-content: space-between;
    margin-top: 10px; font-size: 14px; opacity: 0.8;
  }
  .progress-bars {
    margin-top: 10px;
  }
  .progress-bar {
    background: #2d2d2d;
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 5px;
    height: 14px;
  }
  .progress-bar-fill {
    height: 100%;
    background: var(--primary);
    width: 0%;
    transition: width 0.3s ease;
  }
  @media (max-width: 600px) {
    body { padding: 10px; }
    .card { padding: 15px; }
  }
</style>
</head>
<body>
<header>
  <h1>Bitcoin Key Finder</h1>
  <p>Offline distributed private key search</p>
</header>
<main>
  <div class="card">
    <div class="form-group">
      <label for="startHex">Start Key (HEX):</label>
      <input type="text" id="startHex" value="0000000000000001" />
    </div>
    <div class="form-group">
      <label for="endHex">End Key (HEX):</label>
      <input type="text" id="endHex" value="0000000000001000" />
    </div>
    <div class="form-group">
      <label for="prefix">Address Prefix:</label>
      <input type="text" id="prefix" value="1" />
    </div>
    <div class="form-group">
      <label for="mode">Search Mode:</label>
      <select id="mode">
        <option value="sequential">Sequential</option>
        <option value="random">Random</option>
      </select>
    </div>
    <div class="form-group">
      <label for="workerCount">Number of Workers (Threads):</label>
      <input type="number" id="workerCount" min="1" max="16" value="4" />
    </div>
    <div class="btn-group">
      <button id="toggleBtn">Start Search</button>
      <button id="resetBtn" style="background:#424242">Reset</button>
      <button id="downloadLogBtn" style="background:#2e7d32">Download Log</button>
    </div>
  </div>
  <div class="card">
    <h2>Activity Log</h2>
    <div class="status">
      <span id="status">Ready</span>
      <span id="counter">Keys checked: 0</span>
    </div>
    <div class="progress-bars" id="progressBars"></div>
    <div class="log-container" id="log"></div>
  </div>
</main>
<script>
const startHexInput = document.getElementById('startHex');
const endHexInput = document.getElementById('endHex');
const prefixInput = document.getElementById('prefix');
const modeSelect = document.getElementById('mode');
const workerCountInput = document.getElementById('workerCount');
const toggleBtn = document.getElementById('toggleBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadLogBtn = document.getElementById('downloadLogBtn');
const statusEl = document.getElementById('status');
const counterEl = document.getElementById('counter');
const logEl = document.getElementById('log');
const progressBarsContainer = document.getElementById('progressBars');

let workers = [];
let running = false;
let keysChecked = 0;
let numberOfWorkers = 4;
let progressData = [];

function log(msg, isFound = false) {
  const el = document.createElement('div');
  el.textContent = msg;
  if (isFound) el.classList.add('found');
  logEl.appendChild(el);
  logEl.scrollTop = logEl.scrollHeight;
}

function saveProgress(workerId, currentKey) {
  localStorage.setItem(`progress_worker_${workerId}`, currentKey);
}

function getProgress(workerId) {
  return localStorage.getItem(`progress_worker_${workerId}`) || null;
}

function reset() {
  workers.forEach(w => w.terminate());
  workers = [];
  running = false;
  keysChecked = 0;
  counterEl.textContent = 'Keys checked: 0';
  statusEl.textContent = 'Ready';
  logEl.textContent = '';
  progressBarsContainer.innerHTML = '';
  toggleBtn.textContent = 'Start Search';
  toggleBtn.classList.remove('pause');
  for(let i = 0; i < numberOfWorkers; i++) {
    localStorage.removeItem(`progress_worker_${i}`);
  }
  progressData = [];
}

function createProgressBars(count) {
  progressBarsContainer.innerHTML = '';
  progressData = Array(count).fill(0);
  for(let i = 0; i < count; i++) {
    const container = document.createElement('div');
    container.classList.add('progress-bar');
    const fill = document.createElement('div');
    fill.classList.add('progress-bar-fill');
    fill.id = `progressFill_${i}`;
    container.appendChild(fill);
    progressBarsContainer.appendChild(container);
  }
}

function updateProgressBar(workerId, percent) {
  const fill = document.getElementById(`progressFill_${workerId}`);
  if (fill) fill.style.width = `${percent}%`;
}

function startWorkers() {
  const startHexRaw = startHexInput.value.trim();
  const endHexRaw = endHexInput.value.trim();
  const prefix = prefixInput.value.trim();
  const mode = modeSelect.value;
  numberOfWorkers = Math.min(Math.max(parseInt(workerCountInput.value) || 1, 1), 16);

  if (!startHexRaw || !endHexRaw || !prefix) {
    alert('Fill all fields');
    return;
  }

  // Подготовка диапазонов
  const bigStart = BigInt('0x' + startHexRaw.padStart(64, '0'));
  const bigEnd = BigInt('0x' + endHexRaw.padStart(64, '0'));
  if (bigEnd < bigStart) {
    alert('End key must be greater than start key');
    return;
  }
  const range = bigEnd - bigStart + 1n;
  const part = range / BigInt(numberOfWorkers);

  keysChecked = 0;
  logEl.textContent = '';
  createProgressBars(numberOfWorkers);

  for (let i = 0; i < numberOfWorkers; i++) {
    const worker = new Worker('worker.js');
    const partStart = bigStart + part * BigInt(i);
    const partEnd = (i === numberOfWorkers - 1) ? bigEnd : (partStart + part - 1n);
    const resumeFrom = getProgress(i);

    worker.postMessage({
      cmd: 'start',
      start: partStart.toString(16).padStart(64, '0'),
      end: partEnd.toString(16).padStart(64, '0'),
      prefix,
      mode,
      resumeFrom,
    });

    worker.onmessage = (e) => {
      const data = e.data;
      if (data.type === 'progress') {
        keysChecked++;
        counterEl.textContent = `Keys checked: ${keysChecked}`;

        if (data.found) {
          log(`FOUND: ${data.privateKey} => ${data.address} | WIF: ${data.wif}`, true);
        } else {
          // Можно логировать статус воркера, но не перегружать лог
          // log(`Worker ${i}: Checked ${data.checkedCount} keys`);
        }
        saveProgress(i, data.currentKey);

        // Обновим прогресс-бар воркера (условно % от части диапазона)
        // Здесь для простоты просто инкремент по keysChecked на воркера
        // Можно улучшить, если воркер будет отдавать процент
        // Но пусть сейчас прогресс - грубая оценка
        const progressPercent = ((BigInt('0x' + data.currentKey) - partStart) * 100n) / (partEnd - partStart + 1n);
        updateProgressBar(i, Number(progressPercent));
      }
      if (data.type === 'done') {
        statusEl.textContent = `Worker ${i} finished or paused`;
        saveProgress(i, data.currentKey);
      }
    };

    workers.push(worker);
  }

  running = true;
  toggleBtn.textContent = 'Pause Search';
  toggleBtn.classList.add('pause');
  statusEl.textContent = 'Searching...';
}

toggleBtn.addEventListener('click', () => {
  if (!running) {
    startWorkers();
  } else {
    workers.forEach(w => w.terminate());
    workers = [];
    running = false;
    toggleBtn.textContent = 'Start Search';
    toggleBtn.classList.remove('pause');
    statusEl.textContent = 'Paused';
  }
});

resetBtn.addEventListener('click', reset);

downloadLogBtn.addEventListener('click', () => {
  const blob = new Blob([logEl.textContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `bitcoin_key_finder_log_${Date.now()}.txt`;
  a.click();
  URL.revokeObjectURL(url);
});

reset();
</script>
</body>
</html>
